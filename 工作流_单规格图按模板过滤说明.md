# 应用模板处理商品规格：按模板过滤单规格图

在「应用模板处理商品规格」节点中增加一段逻辑：**从模板中解析出所有规格尺寸（NxN），若某张单规格图识别出的尺寸在模板中不存在，则从轮播图中删除该图**。字面匹配即可（提取 NxN 后比对）。

---

## 1. 模板规格从哪里取

- 节点「**查询【指定】模板**」执行后，其输出为一条记录，含 `data` 字段（可能为字符串，需 `JSON.parse`）。
- `data.productSkuSpecList` 或 `data.productSkuSpecTableData` 中，每个条目的 `"3001"` 值为规格文案，如：`"19.69x29.53 英寸 / 50x75 厘米"`、`"59.06x78.74 英寸 / 150x200 厘米"`。
- 从中用正则提取所有 **数字x数字**（如 50x75、150x200），组成「模板规格集合」。

---

## 2. 要插入的代码（在拿到 image_list 之后、输出之前）

把下面整段插入到「应用模板处理商品规格」里：在已有逻辑拿到 `image_list` 和 `sku_list` 之后，**先对 image_list 做过滤**，再继续后续逻辑（或直接作为最终 image_list 输出）。

```javascript
// ---------- 按模板过滤单规格图：模板中不存在的单规格图从轮播图删除 ----------
function extractNxNSet(templateData) {
  const set = new Set();
  if (!templateData || typeof templateData !== 'object') return set;
  const re = /\d+(?:\.\d+)?[xX×]\d+(?:\.\d+)?/g;
  function addFromStr(val) {
    if (typeof val !== 'string') return;
    re.lastIndex = 0;
    let m;
    while ((m = re.exec(val)) !== null) set.add(m[0].toLowerCase().replace('×', 'x'));
  }
  const skipKeys = { volumeLen: 1, volumeWidth: 1, volumeHeight: 1, weightValue: 1, productSkuId: 1, imageIndex: 1, supplierPrice: 1, suggestedPrice: 1 };
  (templateData.productSkuSpecTableData || []).forEach(item => {
    if (!item) return;
    Object.keys(item).forEach(k => { if (skipKeys[k] == null && item[k] != null) addFromStr(String(item[k])); });
  });
  (templateData.productSkuSpecList || []).forEach(item => {
    if (!item || !item.productSkuSpecs) return;
    Object.values(item.productSkuSpecs || {}).forEach(val => { if (val != null) addFromStr(String(val)); });
  });
  return set;
}
// spec_dimensions 支持 2 或 3 个数字（如 18x22 或 5x18x22），统一为升序 x 连接
function normalizeSpecDim(specDimensions) {
  if (specDimensions == null) return '';
  let str = typeof specDimensions === 'object' ? (specDimensions.cm || specDimensions.inches || '') : String(specDimensions);
  const parts = (str.match(/\d+(?:\.\d+)?/g) || []).map(s => parseFloat(s)).filter(n => !Number.isNaN(n));
  if (parts.length === 0) return '';
  parts.sort((a, b) => a - b);
  const fmt = (n) => n === Math.round(n) ? String(Math.round(n)) : String(Number(n.toFixed(2)));
  return parts.map(fmt).join('x');
}
function imageDimMatchesTemplate(imageDimStr, templateDim) {
  if (!imageDimStr || !templateDim) return false;
  const imageNums = new Set(imageDimStr.trim().split(/[xX×]/).map(p => parseFloat(p.trim())).filter(n => !Number.isNaN(n)));
  const templateParts = templateDim.trim().split(/[xX×]/).map(p => parseFloat(p.trim())).filter(n => !Number.isNaN(n));
  if (templateParts.length < 2) return false;
  return templateParts.every(n => imageNums.has(n));
}

let templateData = null;
try {
  const templateNode = $('查询【指定】模板').first().json;
  if (templateNode && templateNode.data) {
    templateData = typeof templateNode.data === 'string' ? JSON.parse(templateNode.data) : templateNode.data;
  }
} catch (e) {}

const templateSpecSet = extractNxNSet(templateData);

let labels = [];
let carousel = [];
try {
  if ($('合并规格图细分结果').isExecuted && $('合并规格图细分结果').first().json) {
    const merged = $('合并规格图细分结果').first().json;
    labels = merged.labels || [];
    carousel = merged.carousel || [];
  } else {
    const v = $('汇总Vision打标结果').first().json;
    labels = v.labels || [];
    carousel = v.carousel || [];
  }
} catch (e) {}

const norm = (u) => (u || '').split('?')[0];
const urlToLabel = {};
labels.forEach((l, i) => {
  const url = (l.original_url || l.image_url || carousel[i] || '');
  if (norm(url)) urlToLabel[norm(url)] = l;
});

// 过滤：单规格图且识别出的尺寸不在模板中 → 从 image_list 中删除
let image_list = []; // 此处改为你当前节点里已有的 image_list 变量名，若不同请替换
// 若你节点里 image_list 来自 productData，则上面写：let image_list = productData.image_list || [];
image_list = (image_list || []).filter((url) => {
  const lab = urlToLabel[norm(url)];
  if (!lab || lab.spec_subtype !== 'single_spec') return true;
  const dim = normalizeSpecDim(lab.spec_dimensions);
  if (!dim) return true;
  if (templateSpecSet.size === 0) return true;
  return [...templateSpecSet].some(t => imageDimMatchesTemplate(dim, t));
});
// 此处之后：用过滤后的 image_list 继续你原有的 sku_list / 输出逻辑
```

---

## 3. 使用说明

- **节点名**：若你实际用的是「查询【指定】模板列表：毛毯」等，把代码里的 `$('查询【指定】模板')` 改成实际节点名。
- **变量名**：若你节点里轮播图数组不叫 `image_list`，把代码里两处 `image_list` 改成你已有的变量名，并保证「过滤前」那一行拿到的是当前节点里已有的轮播图数组。
- **插入位置**：在「应用模板处理商品规格」里，在已经拿到 `image_list`（和可选的 productData）之后、做模板应用/生成 sku_list 或最终 return 之前，执行上述逻辑，然后用新的 `image_list` 参与后续计算和输出。

这样即可实现：单规格图识别出的尺寸若不在模板的 NxN 集合中，就从轮播图中删除该张图。
