# 原图标签/排除状态不显示 — 排查步骤

## 1. 确认「标签还在不在」

### 方法 A：用调试接口看库里和 OCRPlus

后端已提供接口（需先重新部署）：

```text
GET /api/design/debug-original-labels?id=<mapping_id>
```

- 在浏览器打开设计图审核页，F12 → Network，刷新列表，找到请求 `pending-review`，在 Response 里随便选一条记录，记下它的 `id`。
- 浏览器访问：`https://你的域名/api/design/debug-original-labels?id=刚记下的id`（或本地 `http://localhost:8080/api/design/debug-original-labels?id=xxx`）。

看返回里的 `data`：

- **`db.original_excluded_indices`**：库里存的「排除」下标，有内容说明排除状态在库里还在。
- **`db.original_classify_reasons`**：库里存的打标结果（每条的 `referable`、`reason`），有内容说明打标在库里还在。
- **`ocrplus_has_data`**：当前请求 OCRPlus 是否拿到数据；**`ocrplus_keys_count`**：按 URL 查到了几条。

若 **db 里两项都有内容**，说明数据没丢，问题在「列表接口或前端展示」；若 **db 里为空**，说明数据已丢失或从未写入，要查写库链路（n8n 写回、添加原图接口等）。

---

### 方法 B：直接查数据库

在数据库执行（把 `123` 换成你要查的那条记录的 id）：

```sql
SELECT id,
       original_images_urls,
       original_excluded_indices,
       original_classify_reasons
FROM lovart_design_tab_mapping
WHERE id = 123;
```

- `original_excluded_indices` 非空 → 排除状态在库里。
- `original_classify_reasons` 非空且为合法 JSON 数组 → 打标在库里。

---

## 2. 看列表接口实际返回了什么

- F12 → Network → 刷新设计图审核列表，点开 `pending-review` 的请求。
- 在 Response 里找到同一条记录（同 id），看：
  - **`original_excluded_indices`**：是否和库里一致（若库里有的这里为空，说明列表查询或解析有问题）。
  - **`original_classify_reasons`**：是否和库里一致（若库里有的这里为空或被改掉，可能是 OCRPlus 拉标签后覆盖/合并逻辑有问题）。

---

## 3. 根据结果判断

| 现象 | 可能原因 |
|------|----------|
| 库里 `original_excluded_indices` / `original_classify_reasons` 为空 | 数据没写入或被清空：检查 n8n 写回 set-excluded-originals、添加原图接口是否覆盖了这两列。 |
| 库里有，但 pending-review 返回里该项为空 | 列表 SQL 没查这两列、或解析/合并时被清空；或 OCRPlus 拉标签后合并逻辑把库里的覆盖掉了。 |
| pending-review 返回里有，但页面上不显示 | 前端用错字段（例如没用 `original_classify_reasons` 的 `reason`、或没绑定到原图下标）。 |

---

## 4. 快速自测「标签是否在库里」

1. 用 **方法 A** 或 **方法 B** 查一条你认为「之前打过标/排除过」的记录。
2. 若 `db.original_excluded_indices` 或 `db.original_classify_reasons` 有内容 → **标签还在**，继续看列表返回和前端；若无 → **标签已不在库里**，需从写库链路排查。
