# N8N 整理工作流：改为从库读取品类配置

品类配置已迁到表 `goods_review_category_config`，由审核页「品类配置」维护。工作流不再用 Code 节点里的 map，改为读库。

## 表结构（已存在则跳过）

执行 `goods_review_web/sql/create_category_config.sql`。表字段：config_key, display_name, keywords(JSON), spec_image_index, spec_image_url, template_name, ref_product_template_id, sort_order。

## 工作流改动要点

### 1. 删除「合并品类」节点里的 map，改为先查库再匹配

- **原**：Code 节点「合并品类」内写死 `CATEGORY_CONFIG`、`CATEGORY_KEYWORDS`，根据 `查品类` 的 product_category 做关键词匹配，输出 `_category_config`。
- **改**：
  - 在「取刚抢占的任务」和「查品类」之后，增加一个 **MySQL 节点「读取品类配置表」**：
    - 查询：`SELECT config_key, display_name, keywords, spec_image_index, spec_image_url, template_name, ref_product_template_id FROM goods_review_category_config ORDER BY sort_order ASC, id ASC`
    - 无参数，执行一次得到多行（每行一个品类）。
  - 把「合并品类」改为 **Code 节点**，输入为：上游「取刚抢占的任务」一条、「查品类」一条、「读取品类配置表」多行。
    - 逻辑：从「查品类」取 `product_category` 字符串；遍历「读取品类配置表」的每一行，解析该行的 `keywords`（JSON 数组），若 product_category 包含任一 keyword，则该行即为命中，取出 spec_image_index、spec_image_url、template_name、ref_product_template_id 等，与「取刚抢占的任务」合并输出一条，带 `_category_config`、`product_category`、`category_fallback`（未命中则为 true，表示按默认毛毯）。
    - 若遍历完都未命中，则用「读取品类配置表」里 config_key = 'blanket' 的那一行作为默认；若表里没有 blanket，则写死默认：spec_image_index=2, spec_image_url=原 BLANKET_SPEC_IMAGE_URL, template_name='毛毯采集模板', ref_product_template_id=50。

### 2. 连线

- 取刚抢占的任务 → 查品类（不变）
- 取刚抢占的任务 → 读取品类配置表（新增：同一执行里再拉一次配置表，不依赖「查品类」结果）
- 查品类 → 合并品类
- 读取品类配置表 → 合并品类（合并品类需要两路输入：任务+品类字符串 + 配置表多行）

注意：N8N 里「合并品类」若只能接一个上游，可改为：
- 方案 A：先「合并品类」只接「取刚抢占的任务」+「查品类」，在 Code 里用 **执行时再查一次 MySQL**（即用 N8N 的 MySQL 节点在同一个 workflow 里按名称取「读取品类配置表」的上一次输出）得到配置表多行，再在 Code 里做关键词匹配。
- 方案 B：用 **Merge** 节点把「查品类」和「读取品类配置表」合并成一组输入，再进「合并品类」；但 Merge 通常会把多行乘在一起，不理想。
- **推荐方案 A**：保留「读取品类配置表」为独立 MySQL 节点（无入参，每次执行查一次），在「合并品类」Code 里用 `$('读取品类配置表').all()` 取配置表所有行，再根据「查品类」的 product_category 做关键词匹配，输出一条带 _category_config 的 item。

### 3. 「合并品类」Code 节点示例逻辑（读库 + 关键词匹配）

```javascript
const task = $('取刚抢占的任务').first().json;
const catRow = $('查品类').first().json;
const rawCategory = (catRow && catRow.product_category) ? String(catRow.product_category).trim() : '';

// 从「读取品类配置表」节点取所有行
const configRows = $('读取品类配置表').all().map(i => i.json);
let matched = null;
for (const r of configRows) {
  const keywords = typeof r.keywords === 'string' ? JSON.parse(r.keywords || '[]') : (r.keywords || []);
  for (const kw of keywords) {
    if (kw && String(kw).trim() && rawCategory.includes(String(kw).trim())) {
      matched = r;
      break;
    }
  }
  if (matched) break;
}
if (!matched) {
  matched = configRows.find(r => r.config_key === 'blanket') || {
    config_key: 'blanket',
    spec_image_index: 2,
    spec_image_url: 'https://img.kwcdn.com/product/20195053a14/c2ddafb8-2eee-497c-9c81-c45254e903bf_800x800.png',
    template_name: '毛毯采集模板',
    ref_product_template_id: 50
  };
}
const spec_index = Number(matched.spec_image_index) || 2;
const spec_url = (matched.spec_image_url || '').trim() || 'https://img.kwcdn.com/product/20195053a14/c2ddafb8-2eee-497c-9c81-c45254e903bf_800x800.png';
const _category_config = {
  template_name: (matched.template_name || '').trim() || '毛毯采集模板',
  ref_product_template_id: matched.ref_product_template_id != null ? Number(matched.ref_product_template_id) : 50,
  spec_image_index: spec_index,
  spec_image_url: spec_url
};
const category_fallback = !matched || matched.config_key === 'blanket';
return [{ json: { ...task, product_category: rawCategory || 'blanket', _category_config, category_fallback } }];
```

### 4. 后续节点

- 所有原来用 `$('商品字段内容').first().json._category_config` 的节点**不用改**，只要「合并品类」输出的 `_category_config` 结构不变即可（template_name, ref_product_template_id, spec_image_index，以及可选 spec_image_url）。
- 若表里加了 spec_image_url，上面示例已带出，需要的话下游也可用。

## 小结

- **新增节点**：MySQL「读取品类配置表」——无参查询 `goods_review_category_config` 全表。
- **改节点**：「合并品类」改为用「取刚抢占的任务」「查品类」「读取品类配置表」三路输入，Code 内读库结果 + 关键词匹配，输出一条带 _category_config。
- **连线**：取刚抢占的任务 → 查品类；取刚抢占的任务 → 读取品类配置表；查品类 → 合并品类；读取品类配置表 → 合并品类（或合并品类内用 $('读取品类配置表').all() 即可，不强制连线）。
- 配置统一在审核页「品类配置」维护，工作流只读库，一劳永逸。
