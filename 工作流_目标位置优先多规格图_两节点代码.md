# 去重并确保规格图在目标位置（单 Code 节点）

**目标**：① 目标位放一张规格图（多规格品类=多规格图或默认图；单规格品类=单规格图或默认图）② ≥5 张才去重 ③ 按模板过滤不符合的单规格图 ④ 首图必须是商品主图。全程用 **labels** 的 `spec_subtype` / `image_type` / `spec_dimensions`。

---

## 唯一节点：去重并确保规格图在目标位置

**流程**：上游 → **轮播图处理_去重** → **本 Code 节点** → 下游（应用模板处理商品规格等）。

**前置**：本节点只依赖 **商品字段内容**。多规格/单规格用 `sku_list.length > 1` 判断；按模板过滤单规格图时，规格尺寸从 `sku_list` 的规格文案（如「6x8.65英寸/15x22厘米」）里提取 NxN，不依赖模板节点。

**逻辑复述（与实现一致）**

- **步骤 0**：去重（≥5 张才删），沿用 duplicate_groups。
- **多规格品类**（模板 SKU 行数 > 1）：  
  1. 若列表中已有多规格图：只保留一张，删掉其余多规格图，把这一张放到目标位（从 list 移除所有多规格图后 splice 一张到 targetIndex）。  
  2. 若列表中没有多规格图：在目标位插入默认规格图。  
  3. 在上述之后：删除列表中「是单规格图且尺寸不在模板内」的图。  
  4. 首图必须是 product_display，否则与第一张 product_display 交换。
- **单规格品类**（模板仅 1 种规格）：  
  1. 先按模板过滤单规格图：不符合模板尺寸的单规格图从列表中删除。  
  2. 若存在符合模板的单规格图：从 list 中移除所有单规格图，把一张符合的放到目标位（只留一张在目标位）。  
  3. 若目标位仍不是单规格图（没有符合模板的单规格图）：在目标位插入默认图。  
  4. 首图必须是 product_display。  
  （单规格品类理论上不会出现多规格图；若出现则本节点不处理，人工审核时处理。）
- **首图**：无论多规格/单规格，最后都保证 list[0] 为 product_display（交换）。

```javascript
const norm = (u) => (u || '').split('?')[0];

// ---------- 单规格图按模板过滤（与 应用模板处理 一致：canonicalDim / extractNxNSet / normalizeSpecDim）----------
function canonicalDim(dimStr) {
  if (!dimStr || typeof dimStr !== 'string') return '';
  const m = dimStr.trim().match(/\d+(?:\.\d+)?[xX×]\d+(?:\.\d+)?/);
  if (!m) return '';
  const parts = m[0].toLowerCase().replace('×', 'x').split('x');
  const a = parseFloat(parts[0]), b = parseFloat(parts[1]);
  if (Number.isNaN(a) || Number.isNaN(b)) return '';
  const aStr = a === Math.round(a) ? String(Math.round(a)) : String(a);
  const bStr = b === Math.round(b) ? String(Math.round(b)) : String(b);
  return aStr + 'x' + bStr;
}
// 从商品 sku_list 提取规格文案中的 NxN（与 应用模板 里从模板表提取逻辑一致，数据源改为商品自己的 sku_list）
function extractNxNSetFromSkuList(skuList) {
  const set = new Set();
  if (!Array.isArray(skuList)) return set;
  const re = /\d+(?:\.\d+)?[xX×]\d+(?:\.\d+)?/g;
  function addFromStr(val) {
    if (typeof val !== 'string') return;
    re.lastIndex = 0;
    let m;
    while ((m = re.exec(val)) !== null) { const c = canonicalDim(m[0]); if (c) set.add(c); }
  }
  const skipKeys = { volumeLen: 1, volumeWidth: 1, volumeHeight: 1, weightValue: 1, productSkuId: 1, imageIndex: 1, supplierPrice: 1, suggestedPrice: 1, pic_url: 1 };
  skuList.forEach(sku => {
    if (!sku || typeof sku !== 'object') return;
    Object.keys(sku).forEach(k => { if (skipKeys[k] != null) return; if (sku[k] != null) addFromStr(String(sku[k])); });
  });
  return set;
}
// 支持 2 个或 3 个（长宽高）数字，统一为升序 x 连接（如 18x22 或 5x18x22）
function normalizeSpecDim(specDimensions) {
  if (specDimensions == null) return '';
  let str = '';
  if (typeof specDimensions === 'object') str = specDimensions.cm || specDimensions.inches || '';
  else str = String(specDimensions);
  const parts = (str.match(/\d+(?:\.\d+)?/g) || []).map(s => parseFloat(s)).filter(n => !Number.isNaN(n));
  if (parts.length === 0) return '';
  parts.sort((a, b) => a - b);
  const fmt = (n) => n === Math.round(n) ? String(Math.round(n)) : String(Number(n.toFixed(2)));
  return parts.map(fmt).join('x');
}
// 图片维度（2 或 3 个数）与模板维度（两数）匹配：模板两数都在图片数值集合内即算匹配
function imageDimMatchesTemplate(imageDimStr, templateDim) {
  if (!imageDimStr || !templateDim) return false;
  const imageNums = new Set(imageDimStr.trim().split(/[xX×]/).map(p => parseFloat(p.trim())).filter(n => !Number.isNaN(n)));
  const templateParts = templateDim.trim().split(/[xX×]/).map(p => parseFloat(p.trim())).filter(n => !Number.isNaN(n));
  if (templateParts.length < 2) return false;
  return templateParts.every(n => imageNums.has(n));
}

// ---------- 数据源 ----------
let labels = [], carousel = [];
try {
  if ($('合并规格图细分结果').isExecuted && $('合并规格图细分结果').first().json) {
    const merged = $('合并规格图细分结果').first().json;
    labels = merged.labels || []; carousel = merged.carousel || [];
  }
} catch (e) {}
if (!labels.length) {
  const v = $('汇总Vision打标结果').first().json;
  labels = v.labels || []; carousel = v.carousel || [];
}

const duplicateRes = $input.first().json;
const duplicateInfo = duplicateRes.data || duplicateRes || {};
const duplicateGroups = duplicateInfo.duplicate_groups || [];

const goods = $('商品字段内容').first().json;
const config = goods._category_config || {};
const targetIndex = config.spec_image_index ?? 2;
const defaultSpecUrl = (config.spec_image_url || '').trim();

// 多规格判断 + 规格尺寸集合：仅从「商品字段内容」的 sku_list 读取（sku_list 条数>1=多规格；规格文案中 NxN 用于过滤单规格图）
const skuList = goods.sku_list || [];
const hasMultiSpec = skuList.length > 1;
const templateSpecSetFromGoods = extractNxNSetFromSkuList(skuList);

const urlToSpecSubtype = {};
const urlToImageType = {};
const urlToSpecDimensions = {};
carousel.forEach((url, i) => {
  const u = norm(url);
  if (u) {
    urlToSpecSubtype[u] = (labels[i] && labels[i].spec_subtype) || null;
    urlToImageType[u] = (labels[i] && labels[i].image_type) || null;
    urlToSpecDimensions[u] = (labels[i] && labels[i].spec_dimensions) || null;
  }
});

const isProductDisplay = (url) => urlToImageType[norm(url)] === 'product_display';

let list = carousel.filter(Boolean);
let dedupMsg = '未检测到重复图片，无需去重';

// ---------- 步骤 1：去重（≥5 张才删）----------
if (duplicateGroups.length > 0) {
  const toDelete = new Set();
  duplicateGroups.forEach(group => { if (group && group.length > 1) group.slice(1).forEach(url => toDelete.add(url)); });
  const remain = list.length - toDelete.size;
  if (remain >= 5) {
    list = list.filter(url => !toDelete.has(url));
    dedupMsg = `检测到${duplicateGroups.length}组重复，删除${toDelete.size}张，剩余${list.length}张`;
  } else {
    dedupMsg = '检测到重复但删除后不足5张，保留原列表';
  }
}

const templateSpecSet = templateSpecSetFromGoods;
let specInsertMsg = '';

// ---------- 步骤 2：按多规格/单规格品类处理目标位 + 按模板过滤单规格图 ----------
if (hasMultiSpec) {
  // 多规格品类：1) 已有多规格图 → 只留一张放到目标位；2) 没有多规格图 → 插默认图；3) 删除不符合模板的单规格图
  const multiSpecUrls = list.filter(u => urlToSpecSubtype[norm(u)] === 'multi_spec');
  if (multiSpecUrls.length >= 1) {
    list = list.filter(u => urlToSpecSubtype[norm(u)] !== 'multi_spec');
    list.splice(Math.min(targetIndex, list.length), 0, multiSpecUrls[0]);
    specInsertMsg = '目标位已放入多规格图';
  } else {
    if (defaultSpecUrl) {
      list.splice(Math.min(targetIndex, list.length), 0, defaultSpecUrl);
      specInsertMsg = '目标位已插入默认规格图（多规格品类）';
    }
  }
  list = list.filter(url => {
    if (urlToSpecSubtype[norm(url)] !== 'single_spec') return true;
    const dim = normalizeSpecDim(urlToSpecDimensions[norm(url)]);
    if (!dim || templateSpecSet.size === 0) return true;
    return [...templateSpecSet].some(t => imageDimMatchesTemplate(dim, t));
  });
} else {
  // 单规格品类：1) 删除不符合模板的单规格图；2) 有符合的 → 只留一张放到目标位；3) 目标位仍不是单规格图 → 插默认图
  const matchingSingleSpecUrls = list.filter(u => {
    if (urlToSpecSubtype[norm(u)] !== 'single_spec') return false;
    const dim = normalizeSpecDim(urlToSpecDimensions[norm(u)]);
    return dim && templateSpecSet.size > 0 && [...templateSpecSet].some(t => imageDimMatchesTemplate(dim, t));
  });
  list = list.filter(u => urlToSpecSubtype[norm(u)] !== 'single_spec');
  if (matchingSingleSpecUrls.length >= 1) {
    list.splice(Math.min(targetIndex, list.length), 0, matchingSingleSpecUrls[0]);
    specInsertMsg = '目标位已放入符合模板的单规格图';
  } else if (defaultSpecUrl) {
    list.splice(Math.min(targetIndex, list.length), 0, defaultSpecUrl);
    specInsertMsg = '目标位已插入默认规格图（单规格品类）';
  } else {
    specInsertMsg = '无符合模板的单规格图且无默认图，未插入';
  }
}

// ---------- 步骤 3：首图必须是商品主图 ----------
if (list.length > 0 && !isProductDisplay(list[0])) {
  const firstProductIndex = list.findIndex(u => isProductDisplay(u));
  if (firstProductIndex > 0) {
    [list[0], list[firstProductIndex]] = [list[firstProductIndex], list[0]];
  }
}

let downloadCost = 0, processDuplicateCost = 0;
try {
  const t1 = $('计时1').first().json.currentDate;
  const t2 = $('计时2').first().json.currentDate;
  if (t1 && t2) downloadCost = Number(((new Date(t2) - new Date(t1)) / 1000).toFixed(2));
  if (typeof duplicateInfo.duplicate_detect_time === 'number') processDuplicateCost = duplicateInfo.duplicate_detect_time;
} catch (e) {}

const originalCount = carousel.filter(Boolean).length;
const toDeleteCount = duplicateGroups.reduce((s, g) => s + (g && g.length > 1 ? g.length - 1 : 0), 0);
const finalMessage = specInsertMsg ? `${dedupMsg}; ${specInsertMsg}` : dedupMsg;

return [{
  json: {
    image_list: list,
    image_list_reordered: list,
    download_cost: downloadCost,
    process_raw_cost: 0,
    process_duplicate_cost: processDuplicateCost,
    deduplication_info: {
      has_duplicates: duplicateInfo.has_duplicates || false,
      duplicate_groups: duplicateGroups,
      original_count: originalCount,
      to_delete_count: toDeleteCount,
      deduplicated_count: list.length,
      deduplicated: list.length !== originalCount,
      reason: dedupMsg
    },
    top_score_info: { target_index: targetIndex },
    audit_tips: '',
    message: finalMessage
  }
}];
```

---

**操作清单**

| 操作 | 说明 |
|------|------|
| 删节点 | 「判断目标位置是否已是规格图」「目标位置已是规格图？」（IF）、「从Vision构建raw数据」「合并raw与去重」「确保规格图在目标位置 + 删除重复图片」、「轮播图处理_去重_快速通道」「快速通道输出」 |
| 保留 | 只保留一个去重 HTTP：**轮播图处理_去重**（body 仍用 商品字段内容 + 轮播图下载） |
| 连线 | 上游（如 计时Vision后 或 合并规格图细分结果 之后）→ 轮播图处理_去重 → **本 Code 节点**（名称：去重并确保规格图在目标位置）→ 下游（应用模板处理商品规格等） |
| 下游 | 原接 快速通道输出 / 确保规格图在目标位置 的节点，一律改为接本 Code 节点 |
