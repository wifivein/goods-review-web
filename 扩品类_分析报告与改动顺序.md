# 扩品类：毛毯逻辑梳理 + 分析报告与改动顺序

## 一、说明：服务端 N8N 与本地范围

**我无法直接访问你服务端 N8N 的实时配置**，只能基于当前 Cursor_project 仓库内的文件做分析。

- **仓库里**：`installer/` 下只有 `n8n_采集推荐区发现新店铺_工作流.json` 等少量导出；**没有**「店铺采集」「完成一个店铺的采集」等完整工作流的 JSON。
- **你之前改过的**「【店铺】完成一个店铺的采集 (6).json」在 **Downloads**，不在本仓库，所以**服务端 N8N 上所有带「毯子/毛毯」的工作流**需要你本人在 N8N 里搜一遍确认。

下面列出：  
① 仓库内能确定的、和毛毯/规格图写死相关的所有位置；  
② **商品整理工作流**「【商品】整理一条待上传的商品」的节点与接口清单；  
③ 按「商品整理发布」全环节尽快适配多品类的**修改计划**。

---

## 1.5 商品整理工作流「【商品】整理一条待上传的商品」— 节点与接口

（基于 `Downloads/【商品】整理一条待上传的商品 (40).json` 梳理。）

### 写死毛毯/第 3 格的节点

| 节点名 | 类型 | 写死内容 | 说明 |
|--------|------|----------|------|
| **查询【指定】模板列表：毛毯** | MySQL | `WHERE name = '毛毯采集模板'`，表 `template_info_v2` | 只查毛毯模板；新品类需查对应模板名或按品类传参 |
| **应用模板处理商品标题** | Code | `targetTemplateNodeName = "查询【指定】模板列表：毛毯"`；用该节点输出取 `hide_words`/`pre_words` | 依赖上节点名与输出，换品类需改节点名或改为从输入拿「当前品类模板」 |
| **应用模板处理商品规格** | Code | `targetTemplateName = "毛毯采集模板"`；`$('快速通道输出').isExecuted ? ... : $('确保规格图在第3格 + 删除重复图片')` | 模板名写死；数据源依赖「第3格」节点名 |
| **引用模板【毛毯】** | HTTP Request | `ref_product_template_id: 50`（body 写死）；Sticky Note 注明「写死了毛毯的模板ID=50」 | 供应商侧模板 ID，你自配；工作流需按品类传不同 template_id |
| **判断第3格是否已是规格图** | Code | `const third = labels[2];`、`isSpec = third && third.image_type === 'spec'` | 固定看第 3 格（index=2）；新品类规格图可能在第 2 格等，需按品类 index |
| **第3格已是规格图？** | IF | 分支名与上游「第3格」逻辑一致 | 语义是「规格图是否已在目标格」，目标格应随品类变 |
| **确保规格图在第3格 + 删除重复图片** | Code | 去重后若需重排，把规格图放到第 3 格（index=2） | 目标格写死为 3；新品类需改为「放到 spec_image_index」 |
| **汇总Vision打标结果** | Code | 注释「供第3格判断、从Vision构建raw…」 | 下游用 index 2，改下游即可 |
| **整理结果写回**（拼接/写回等） | - | 数据来源含「快速通道」或「确保规格图在第3格…」 | 节点名引用，随「第3格」节点改名或参数化可一并改 |

### 工作流引用的接口（与实现位置）

| 接口 | 用途 | 实现位置 / 说明 |
|------|------|------------------|
| `POST https://gwfpod.com/api/collect/product/batch_update` | 回存商品到供应商（标题、轮播图、SKU） | **供应商侧**，你自配；本仓库仅 `app.py` 里 `SAVE_API_URL` 同 URL，审核通过后回存用 |
| `POST https://gwfpod.com/api/collect/product/batch_set_ref_product_template_id` | 设置商品引用模板 ID（当前 body 写死 `ref_product_template_id: 50`） | **供应商侧**，你自配；工作流需按品类传不同 ID |
| `POST http://goods_review_frontend/api/goods/update-main-fields` | 整理完成后写回商品主字段（product_name, carousel_pic_urls, sku_list, preprocess_tags, process_status） | **goods_review_web**：`app.py` 约 1355 行 `update_goods_main_fields()`，仅写 DB，无毛毯逻辑 |
| `POST http://goods_review_frontend/api/vision/describe` | Vision 打标（轮播图标签） | **goods_review_web**：`app.py` 约 934 行；与品类无关 |
| `GET http://preview-lab:5003/api/prompt/current?scene=carousel_label` | 拉取轮播图打标 prompt | **preview-lab**；与品类无关 |
| `POST http://ocrplus:5002/api/image/download` | 轮播图下载 | OCRPlus 服务 |
| `POST http://ocrplus:5002/api/ocr/duplicate/detect` | 重复图检测 | OCRPlus 服务 |
| `POST http://ocrplus:5002/api/image/labels/batch` | 批量写图片标签到 image_assets | OCRPlus 服务 |

**结论**：  
- **goods_review_web** 在本工作流里只提供 `update-main-fields`、`vision/describe`，无写死毛毯；多品类需改的是**审核页与审核通过逻辑**（见下）。  
- **写死毛毯的**都在 N8N 节点内：模板名、模板节点名、第 3 格 index、`ref_product_template_id`。  
- **供应商 gwfpod** 的 `batch_update` / `batch_set_ref_product_template_id` 你自行按品类配置即可。

---

## 二、写死「毛毯/毯子/第 3 格」的位置汇总

### 2.1 N8N 工作流（需你在服务端自查）

以下逻辑通常出现在**店铺采集类**工作流里，请在你的 N8N 里用关键词搜索节点名或节点内容：

| 类型 | 关键词 / 可能节点名 | 说明 |
|------|---------------------|------|
| 点击类目 | `毯子`、`text:h2:毯子`、点击【毯子】、再尝试点击【毯子】 | HTTP Request / 扩展点击节点 body 里的 selector、texts |
| 判断有无类目 | `有毯子？`、`没有毯子？`、`该店铺没有毯子`、判断是否有毯子 | IF / 检查页面文案 等节点 |
| 过滤关键词 | `电热毯\|户外毯\|兔毛\|兔绒毯\|天鹅绒\|牛奶绒\|雪纺\|提花\|羊羔绒\|睡袋绒\|长毛绒\|应急\|流苏\|粗针`、`毛皮毯\|针织\|雪尼尔\|可穿戴\|可戴\|戴帽\|连帽\|帽毯\|帽式毯\|披毯\|圆形\|圆型\|圆毯\|夜光\|枕套` | Filter 节点里的 `rightValue` 正则（排除非目标毯子） |
| 模板/查询 | `查询【指定】模板列表：毛毯` | 若存在「指定模板」节点，可能写死「毛毯」 |

**建议**：在 N8N 里全局搜 `毯子`、`毛毯`，逐个打开包含这些词的节点，看是文案、selector 还是 Filter 条件，并记下工作流名 + 节点名，便于后续改「品类可配置」或复制工作流改挂毯/新品类。

---

### 2.2 仓库内与 N8N 相关的文档/配置（无运行时，仅参考）

| 文件 | 内容概要 |
|------|----------|
| `installer/采集扩展_自动发现店铺与挂毯品类_细拆.md` | 写明了：点击类目/判断类目/Filter 的毛毯→挂毯改动；规格图第 3 格(毛毯) vs 第 2 格(挂毯)；品类配置建议 |
| `installer/采集提速_节点改动清单.md` | 点击「毯子」等 waitAfter 数值 |
| `installer/采集工作流_提效节点建议.md` | 点击【毯子】waitAfter |
| `installer/n8n_第3格优先_*.md` | 第 3 格规格图、快速通道、查询模板列表：毛毯 等 |
| `chrome_extension/src/background.js` | 注释里 `// text:毯子`、`// text:h2:毯子`（未在运行逻辑里用） |

---

### 2.3 商品审核 Web（goods_review_web）— 写死「第 3 张/规格图 index=2」

#### 后端 `backend/app.py`

| 位置 | 内容 | 说明 |
|------|------|------|
| 约 49–50 行 | `BLANKET_SPEC_IMAGE_URL`、注释「毛毯标准规格图」「替换第 3 张图」 | 全局常量，仅毛毯 |
| 约 364–372 行 | `replaced_3rd_image_url` 加回 `query_list[2]` | 出图/query 用轮播图时，把「被替换掉的原第 3 张」加回第 3 位；写死 index=2 |
| 约 1435、1481–1484、1512–1515、1518–1537 行 | `approve_goods()`：不足 3 张作废；`image_list[2] = BLANKET_SPEC_IMAGE_URL`；`replaced_3rd_image_url` 存原第 3 张；同步 mapping | **核心**：审核通过固定替换第 3 张为毛毯规格图 |
| 约 1573 行 | `_notify_preview_lab_feedback(..., payload={"first_image_index": 0, "spec_image_index": 2})` | 通知 preview-lab 时写死规格图在第 3 格 |

#### 前端 `frontend/index.html` + `app.js`

| 位置 | 内容 | 说明 |
|------|------|------|
| index.html 约 1008–1011、1121–1124 行 | 文案「第3张」、`goodsList[0].image_list[2]` / `goods.image_list[2]` | 移动端/桌面端都**固定展示第 3 张**为「第3张」格 |
| index.html 约 1255 行 | 按钮「更换第3张图」 | 文案写死 |
| app.js 约 320、333–358、558–566、623–647、666 行 | 更换第 3 张图、主图/规格图更新提示 | 全部按「第 3 张」写死，非毛毯时规格图可能不在第 3 格会错位 |

#### 数据库 / SQL

| 文件 | 内容 | 说明 |
|------|------|------|
| `sql/add_replaced_3rd_image_url.sql` | `replaced_3rd_image_url` 注释「审核通过时第3张会被替换」 | 字段名和语义都是「第 3 张」 |

---

### 2.4 preview-lab

- 已按 **scene** 设计，未写死毛毯；文档写明 `spec_image_index` 按 scene/配置区分。
- 当前只有 **goods_review_web 在 approve 时**把 `spec_image_index: 2` 写死传过去；改成按品类从配置读取即可。

---

### 2.5 OCRPlus（与审核流程无直接绑定）

- `classify_samples.py`、`rule_miner.py`、`optimal_rules.json` 等里出现 **blanket** 关键词，用于**规格图检测**的样本/规则，属于 OCR 能力，不是「审核通过替换第几张」的逻辑；扩品类后若新品类也有规格图，可后续再加新品类关键词或 scene，不必在第一批改动里动。

---

## 三、非毛毯时「规格图不在第 3 格」的影响

- **后端**：审核通过仍会把 `image_list[2]` 换成毛毯规格图，非毛毯品类的商品会被错误替换第 3 张。
- **前端**：始终把「第 3 张」当重点展示并支持「更换第3张图」，非毛毯若规格图在第 2 格或第 1 格，审核员看不到「规格图格」的正确位置，容易误操作。
- **preview-lab**：收到的 `spec_image_index` 固定为 2，与真实规格图位置可能不一致。

因此扩品类前，**必须先做「品类 → spec_image_index + spec_image_url」的配置与使用**，再放开新品类审核。

---

## 四、建议的扩品类改动顺序（采集稍后，先人工采新品类）

整体思路：**先让「审核 Web + 后端」支持多品类（规格图位置可配），再动 N8N 工作流里的毯子逻辑；采集流程你已打算先人工采几天，可排后。**

### 阶段 1：后端 + 配置（优先）

1. **品类配置**
   - 新增配置来源二选一或组合：
     - **DB**：如 `goods_review_config` 或新表，`ckey` 如 `category_spec_blanket`，`cvalue` 如 `{"spec_image_index":2,"spec_image_url":"https://..."}`；
     - 或 **代码内 dict**：`CATEGORY_SPEC = {"blanket": {"spec_image_index": 2, "spec_image_url": "..."}, "新品类": {"spec_image_index": 1, "spec_image_url": "..."}}`，便于后续再迁到 DB。
   - 当前表 `temu_goods_v2` 若无品类字段，需**新增字段**（如 `product_category` 或 `category`），取值如 `blanket` / `新品类`；来源可以是采集时写入，或审核页先做「默认毛毯、可切换品类」再写入。

2. **审核通过逻辑 `approve_goods()`**
   - 根据商品**品类**（从新字段或默认）取 `spec_image_index`、`spec_image_url`。
   - 用「替换第 N 张」替代写死的 `image_list[2]` 和 `BLANKET_SPEC_IMAGE_URL`；`replaced_3rd_image_url` 可改名为 `replaced_spec_image_url` 或保留字段名但语义改为「被替换掉的那张（原 spec 位）的 URL」。
   - 同步 SKU 里对应 pic 的替换、`image_goods_mapping`、`replaced_*` 的写入，都按「第 N 张」来算 N。
   - 不足 N+1 张（或不足 3 张）时的作废逻辑可保留或按品类最小张数配置。

3. **出图/query 用轮播图 `_process_goods_row`**
   - 若有「把被替换掉的原图加回」的逻辑，改为按**该商品品类对应的 spec_image_index** 把原图加回对应位置，而不是写死 `query_list[2]`。

4. **preview-lab 通知**
   - `_notify_preview_lab_feedback(..., payload={"first_image_index": 0, "spec_image_index": ...})` 中的 `spec_image_index` 从品类配置读，不再写死 2。

### 阶段 2：商品审核页前端（紧跟）

5. **「第 3 张」改为「规格图」且位置按品类**
   - 列表/详情用的「第3张」展示改为「规格图」：用当前商品的 `product_category`（或后端在列表接口里根据品类配置带出 `spec_image_index`）取 `image_list[spec_image_index]` 展示；无品类时默认 2（兼容现有毛毯）。
   - 按钮「更换第3张图」改为「更换规格图」或「更换第 N 张图」（N 由品类决定）。
   - `app.js` 里更换第 3 张的接口/逻辑改为「更换第 spec_image_index 张」或新接口「更换规格图位」传 `index`。

6. **可选：审核页选择品类**
   - 若商品表已有品类字段，列表/详情可展示当前品类；若无，可先默认毛毯，或加「本单审核品类」选择（写入商品或仅当次使用），便于你人工采的新品类能选「新品类」再审核。

### 阶段 3：N8N 工作流（你服务端自查后改）

7. **在 N8N 里搜「毯子」「毛毯」**
   - 打开每个命中节点，确认是「点击类目」「判断类目」「Filter 排除词」「模板列表名」等，并记录工作流名 + 节点名。

8. **改法二选一**
   - **A. 多工作流**：复制一份「店铺采集」改名为「店铺采集-挂毯」（或新品类），仅改该类目相关节点（点击挂毯/新类目、对应 Filter、模板名等），不动原毛毯工作流。
   - **B. 单工作流 + 参数**：若 N8N 支持从外部传入「当前品类」或「类目名/模板名」，可把「毯子/毛毯」改为从参数读，避免复制整份工作流。

9. **采集流程（详情→推荐→详情、控速等）**
   - 按你计划**稍后再做**；新品类先人工采几天，等上述审核与 N8N 改完再接自动化。

### 阶段 4：DB 与历史数据（按需）

10. **temu_goods_v2 增加品类字段**
    - 如 `product_category VARCHAR(32) DEFAULT 'blanket'`，并做一次 backfill：已有数据设为 `blanket`。
11. **replaced_3rd_image_url 语义**
    - 若保留字段名，只改语义为「被替换的规格图位置原 URL」；或新增 `replaced_spec_image_url`，旧字段逐步废弃。

---

## 五、小结表：改动顺序与优先级

| 顺序 | 项目 | 说明 |
|------|------|------|
| 1 | 品类配置 + 审核通过按品类替换 | 后端配置 + approve 用 spec_image_index / spec_image_url，不再写死第 3 格与毛毯 URL |
| 2 | 审核页前端「规格图」按品类展示与更换 | 第 3 张 → 规格图（按品类 index），按钮与接口改为按 index |
| 3 | 出图/query、preview-lab 通知按品类 | 替换位、通知 payload 的 spec_image_index 从配置读 |
| 4 | N8N 工作流内毯子/毛毯逻辑 | 服务端搜「毯子」「毛毯」后，按多工作流或参数化改 |
| 5 | 采集流程（详情→推荐、控速） | 稍后；新品类先人工采 |

这样可以先支撑「新品类人工采 + 审核页正确展示与通过」，再逐步接 N8N 与自动化采集。

---

## 六、商品整理发布环节：多品类修改计划（目标：兼容所有品类）

范围：**从「整理工作流」到「审核通过」**，不包含采集、供应商模板配置、出单出图。

### 6.1 原则

- **品类来源**：商品在进入整理/审核前需带品类（如 `product_category`）。来源可以是：采集时写入、或整理工作流入参、或审核页选择后写回；先保证「有字段可读」。
- **规格图位置**：由「品类 → spec_image_index / spec_image_url」配置决定，不再写死第 3 格与毛毯 URL。
- **供应商侧**（gwfpod 的模板 ID、不同品类模板）：你自配，不列在此。

### 6.2 修改清单（按执行顺序）

#### A. 后端与数据（goods_review_web + DB）

| 序号 | 改动 | 说明 |
|------|------|------|
| A1 | 品类配置 | 新增配置：品类 → `spec_image_index`、`spec_image_url`（DB 表 `goods_review_config` 或代码 dict）。毛毯：index=2、URL 用现 `BLANKET_SPEC_IMAGE_URL`；新品类按你规则加。 |
| A2 | temu_goods_v2 增加品类字段 | 如 `product_category VARCHAR(32) DEFAULT 'blanket'`；backfill 已有数据为 `blanket`。 |
| A3 | approve_goods() 按品类替换 | 读商品 `product_category`，取配置的 spec_image_index、spec_image_url；替换 `image_list[N]`、SKU 中对应 pic、`replaced_3rd_image_url`（或改为 replaced_spec_image_url 语义）、mapping；不足张数作废逻辑可保留或按品类配置。 |
| A4 | _process_goods_row 按品类加回原图 | 把「被替换掉的原规格图」加回时，用该商品品类的 spec_image_index，不再写死 2。 |
| A5 | preview-lab 通知 | approve 时 payload 的 `spec_image_index` 从品类配置读。 |
| A6 | update-main-fields（可选） | 若整理工作流会传 `product_category`，在此接口增加对 `product_category` 的更新，便于整理阶段就写入品类。 |

#### B. 审核页前端（goods_review_web）

| 序号 | 改动 | 说明 |
|------|------|------|
| B1 | 列表/详情「第3张」→「规格图」 | 展示用 `image_list[spec_image_index]`，spec_image_index 来自当前商品品类配置（或接口带出）；无品类时默认 2。 |
| B2 | 按钮「更换第3张图」→「更换规格图」 | 文案改；调用接口改为「更换第 spec_image_index 张」或现有 swap/replace 接口传 index。 |
| B3 | app.js 更换逻辑 | 所有「第 3 张」的写死 index 改为从商品品类或接口返回的 spec_image_index 取。 |
| B4 | 可选：审核页品类选择 | 若商品暂无品类，可加下拉/选择「当前审核品类」，提交时写回 `product_category` 或仅当次审核用该品类配置。 |

#### C. 商品整理工作流（N8N「【商品】整理一条待上传的商品」）

| 序号 | 改动 | 说明 |
|------|------|------|
| C1 | 入参带品类 | 工作流入口增加「品类」参数（如 `category`），或从上游「取任务」节点带出 `product_category`，供后续节点使用。 |
| C2 | 查询模板 | 「查询【指定】模板列表：毛毯」改为按品类查：如 `WHERE name = ?` 用 `category` 拼模板名（如「毛毯采集模板」「挂毯采集模板」），或新表「品类 → 模板名」配置。 |
| C3 | 应用模板处理标题/规格 | 「应用模板处理商品标题」不再写死节点名「查询【指定】模板列表：毛毯」，改为从输入拿「当前模板」或按 `category` 取对应节点输出；「应用模板处理商品规格」同理，`targetTemplateName` 按品类拼或从输入取。 |
| C4 | 第3格 → 规格图 index | 「判断第3格是否已是规格图」改为「判断规格图位是否已是规格图」：用 `labels[spec_image_index]`，spec_image_index 从品类配置或工作流参数来；「确保规格图在第3格…」改为「确保规格图在目标格…」，目标 index 按品类。 |
| C5 | 引用模板 | 「引用模板【毛毯】」改为按品类传 `ref_product_template_id`：从配置或参数取「品类 → 模板ID」再 POST，不再写死 50。 |

#### D. 不改动 / 你自配

- 采集流程（先人工采新品类）。
- gwfpod 的 `batch_update`、`batch_set_ref_product_template_id` 及不同品类模板 ID。
- 出单后出图逻辑（新品类以后再说）。

### 6.3 建议实施顺序

1. **A1+A2**：品类配置 + 表与 backfill，保证有品类可读。  
2. **A3+A4+A5**：审核通过与出图/query、preview-lab 全按品类，审核页逻辑闭环。  
3. **B1～B4**：审核页前端规格图展示与更换，兼容多品类。  
4. **C1～C5**：整理工作流入参、模板查询、标题/规格应用、规格图位、引用模板，全部按品类或参数，不再写死毛毯/第3格。

这样「商品整理发布」整条链路即可兼容所有品类，不绑死毛毯。

---

## 七、品类来源：淘金出海采集助手写 access_logs（可行性与风险）

**背景**：供应商侧商品无「品类」字段，品类靠绑定模板体现；我们整理/审核需要先有品类。人工采和程序采的**最后一步采集动作**都由「淘金出海采集助手」完成（调用供应商 `report_collect`）。若在插件里采集成功后**顺带往我们库写一条 access_logs**，即可用「原商品 ID + access_logs」做对应，并顺带记品类（若能从页面取到）。

**结论**：可行。**必须区分人工/系统点击**：系统点击时工作流侧（N8N + 我们扩展/本地服务）会记 access_logs，插件若再记会重复；故插件**仅人工点击时**写我们库。通信走**现有本地 http-server-v2**（与 N8N、扩展同机），无 CORS、无需公网。

### 7.1 为何必须区分人工 vs 系统点击

- **系统点击**：N8N 工作流 → 调我们 `chrome_extension` 的 HTTP API（如 `click-element`/`click-element-by-url`）→ 扩展在商品详情页点击「采集此商品」→ 淘金出海执行 report_collect。这条链路上，**工作流侧**会在某步记录 access_logs（例如 N8N 调「记录访问」接口，或我们本地服务在打开页/点击后记录）。
- **人工点击**：用户自己在 Temu 商品页点「采集此商品」→ 只有淘金出海执行 report_collect，**没有别处记 access_logs**。
- 若插件在**每次**采集成功都写我们库，系统点击会变成「工作流记一条 + 插件再记一条」重复。所以插件应**仅当本次点击是人工触发时**才写 access_logs。

### 7.2 插件结构（当前）

- **content.js**：只在 `temu.com` 商品详情页（`/g-xxx.html`）注入，读 `data-raw-goods`，点「采集此商品」后组 payload，`sendMessage({ action: "collectItems", data })`。
- **background.js**：收到 `collectItems` 后调供应商 `report_collect`，成功则返回。
- **config.js**：仅供应商 API_BASE_URL。

### 7.3 我们侧的通信手段（插件可复用）

项目里插件/采集侧与「我们服务端」通信的方式已有多种，**淘金出海不必直连公网后端**，用本地即可：

| 方式 | 说明 | 淘金出海是否适用 |
|------|------|------------------|
| **本地 HTTP 服务** | `chrome_extension/local_services/http-server-v2.js`，端口 8888/8889，N8N 与桥接页都调它；**已连 MySQL、已有 `recordAccessLogAsync`**，仅未暴露「写访问记录」的 API。 | ✅ 适用。淘金出海与扩展同机，可 `fetch('http://127.0.0.1:8888/api/collect/access-log', ...)`，无 CORS，无需公网。 |
| 桥接页 + 扩展 | N8N → HTTP 服务 → 桥接页轮询 → 扩展 background。 | 扩展内部用；淘金出海是另一扩展，不直接走桥接。 |
| Native Messaging | 扩展连本机 Native Host。 | 我们侧可选；淘金出海写 access_log 用 HTTP 即可。 |

**推荐**：在 **http-server-v2.js** 新增 `POST /api/collect/access-log`，body 与现有 `recordAccessLogAsync` 入参对齐（url、goods_id、name、page_type、result、bridge_id 等），并支持可选 `product_category`；内部调 `recordAccessLogAsync`。淘金出海 config 配 `ACCESS_LOG_BASE_URL = 'http://127.0.0.1:8888'`（或实际端口），仅**人工点击**时在 report_collect 成功后请求该接口。

### 7.4 区分人工 / 系统点击的实现方式

- **约定**：我们扩展（chrome_extension）在「执行点击采集按钮」之前，向**该 tab** 注入页面脚本，设置 `window.__COLLECT_BY_SYSTEM__ = true`。淘金出海 content 在「采集此商品」的点击回调里读取该标记：若为 `true` 则视为系统点击，传 `trigger: 'programmatic'` 并**立即删除**该标记（避免下次人工点击被误判）；否则 `trigger: 'manual'`。
- **我们扩展改动**：在 `clickElement` / `clickElementByUrl` 等执行「点击目标元素」的**前一拍**，若判定当前是「点击采集按钮」（例如 selector 为 `#collectThisGoods` 或文本含「采集此商品」），先对该 tab 执行 `chrome.scripting.executeScript({ target: { tabId }, func: () => { window.__COLLECT_BY_SYSTEM__ = true; } })`，再执行原有点击逻辑。
- **淘金出海改动**：content 组 payload 时增加 `trigger: window.__COLLECT_BY_SYSTEM__ ? 'programmatic' : 'manual'`，若为 programmatic 则 `delete window.__COLLECT_BY_SYSTEM__`；background 在 report_collect 成功后，**仅当 `trigger === 'manual'`** 时再 `fetch(ACCESS_LOG_BASE_URL + '/api/collect/access-log', ...)`。

这样系统点击时插件不写我们库（由工作流侧已记），人工点击时插件写一条，不重复。

### 7.5 可行方案汇总

| 项 | 做法 |
|----|------|
| **我们侧接口** | 在 **http-server-v2.js** 新增 `POST /api/collect/access-log`，body：`url`、`goods_id`、`name`、`page_type`、`result` 等（与 `recordAccessLogAsync` 一致），可选 `product_category`；内部调 `recordAccessLogAsync`。`access_logs` 表若无 `product_category` 需加列。可选：query/header 简单 token 防滥调。 |
| **插件 config** | 增加 `ACCESS_LOG_BASE_URL`（如 `http://127.0.0.1:8888`），与现有供应商 API 分离。 |
| **插件 background** | report_collect 成功后，**仅当 `trigger === 'manual'`** 时 `fetch(ACCESS_LOG_BASE_URL + '/api/collect/access-log', { method: 'POST', body: JSON.stringify({ url, goods_id, name, product_category, ... }) })`；失败只 log，不挡采集成功提示。 |
| **插件 content** | 点击时读 `window.__COLLECT_BY_SYSTEM__`，传 `trigger: 'programmatic'|'manual'`；若为 programmatic 则 `delete window.__COLLECT_BY_SYSTEM__`。组 payload 前按配置从 DOM 取品类（见下）。 |
| **品类从页面取** | content 内用配置的 selector（面包屑/类目）从 DOM 取文本，映射成我们品类码；取不到则 `product_category` 不传或 null。 |
| **我们扩展** | 在「点击采集按钮」前对该 tab 注入 `window.__COLLECT_BY_SYSTEM__ = true`（仅当 selector/文案表明是采集按钮时）。 |

### 7.6 风险与注意点

| 风险 | 说明与缓解 |
|------|------------|
| **重复/顺序** | 只应在 report_collect **成功**后再写我们库；且仅 manual 时写。我们接口失败不阻塞插件。 |
| **品类配置错误** | selector 配错可接受为未分类，后续整理/审核再选。 |
| **插件维护** | 我们改的是供应商插件，需自行维护 fork 或请对方合并。 |
| **access_logs 表** | 若加 `product_category` 列，需 ALTER；回填/整理时用该列做品类来源。 |
| **端口** | 淘金出海与 http-server-v2 须同机；端口以实际为准（8888/8889）。 |

### 7.7 实施顺序建议

1. **我们侧**：`access_logs` 加列 `product_category`（若无）；http-server-v2 新增 `POST /api/collect/access-log`，调 `recordAccessLogAsync`。  
2. **淘金出海**：config 加 `ACCESS_LOG_BASE_URL`；content 读 `__COLLECT_BY_SYSTEM__` 传 `trigger`、取品类；background 仅 `trigger === 'manual'` 时调我们接口。  
3. **我们扩展**：在点击「采集此商品」前注入 `window.__COLLECT_BY_SYSTEM__ = true`。  
4. 品类 selector：先做一版 Temu 商品页类目 selector，能取到再改成配置。

这样人工采有 access_logs + 可选品类，系统采不重复记，通信走本地无 CORS。
